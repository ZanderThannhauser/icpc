#include "json.h"

#include <limits.h>
#include <stdarg.h>
#include <string.h>
#include <unistd.h>
#include <stdlib.h>
#include <assert.h>
#include <stdio.h>
#include <errno.h>

const unsigned zebu_shifts[61][12] = {
	[1][2] = 2,
	[1][3] = 3,
	[1][4] = 4,
	[1][5] = 5,
	[1][6] = 6,
	[5][2] = 8,
	[5][3] = 9,
	[5][4] = 10,
	[5][5] = 11,
	[5][6] = 13,
	[5][8] = 12,
	[6][2] = 15,
	[6][9] = 16,
	[11][2] = 8,
	[11][3] = 9,
	[11][4] = 10,
	[11][5] = 11,
	[11][6] = 13,
	[11][8] = 18,
	[13][2] = 15,
	[13][9] = 20,
	[14][8] = 23,
	[14][10] = 22,
	[15][11] = 25,
	[17][9] = 27,
	[17][10] = 26,
	[19][8] = 30,
	[19][10] = 29,
	[21][9] = 33,
	[21][10] = 32,
	[22][2] = 8,
	[22][3] = 9,
	[22][4] = 10,
	[22][5] = 11,
	[22][6] = 13,
	[25][2] = 36,
	[25][3] = 37,
	[25][4] = 38,
	[25][5] = 39,
	[25][6] = 40,
	[26][2] = 15,
	[29][2] = 8,
	[29][3] = 9,
	[29][4] = 10,
	[29][5] = 11,
	[29][6] = 13,
	[32][2] = 15,
	[35][8] = 23,
	[35][10] = 22,
	[39][2] = 8,
	[39][3] = 9,
	[39][4] = 10,
	[39][5] = 11,
	[39][6] = 13,
	[39][8] = 46,
	[40][2] = 15,
	[40][9] = 48,
	[42][9] = 27,
	[42][10] = 26,
	[43][8] = 30,
	[43][10] = 29,
	[44][9] = 33,
	[44][10] = 32,
	[47][8] = 54,
	[47][10] = 53,
	[49][9] = 57,
	[49][10] = 56,
	[53][2] = 8,
	[53][3] = 9,
	[53][4] = 10,
	[53][5] = 11,
	[53][6] = 13,
	[56][2] = 15,
	[59][8] = 54,
	[59][10] = 53,
	[60][9] = 57,
	[60][10] = 56,
};


const unsigned zebu_reduces[63][11] = {
	[2][7] = 1,
	[3][7] = 2,
	[4][7] = 3,
	[7][7] = 4,
	[8][8] = 1,
	[8][10] = 1,
	[9][8] = 2,
	[9][10] = 2,
	[10][8] = 3,
	[10][10] = 3,
	[12][7] = 5,
	[16][7] = 6,
	[18][8] = 5,
	[18][10] = 5,
	[20][8] = 6,
	[20][10] = 6,
	[23][7] = 7,
	[24][7] = 8,
	[27][7] = 9,
	[28][7] = 10,
	[30][8] = 7,
	[30][10] = 7,
	[31][8] = 8,
	[31][10] = 8,
	[33][8] = 9,
	[33][10] = 9,
	[34][8] = 10,
	[34][10] = 10,
	[36][9] = 1,
	[36][10] = 1,
	[37][9] = 2,
	[37][10] = 2,
	[38][9] = 3,
	[38][10] = 3,
	[41][9] = 11,
	[41][10] = 11,
	[45][7] = 12,
	[46][9] = 5,
	[46][10] = 5,
	[48][9] = 6,
	[48][10] = 6,
	[50][7] = 13,
	[51][8] = 12,
	[51][10] = 12,
	[52][8] = 13,
	[52][10] = 13,
	[54][9] = 7,
	[54][10] = 7,
	[55][9] = 8,
	[55][10] = 8,
	[57][9] = 9,
	[57][10] = 9,
	[58][9] = 10,
	[58][10] = 10,
	[61][9] = 12,
	[61][10] = 12,
	[62][9] = 13,
	[62][10] = 13,
};


const unsigned zebu_gotos[61][5] = {
	[1][1] = 7,
	[5][1] = 14,
	[6][2] = 17,
	[11][1] = 19,
	[13][2] = 21,
	[14][3] = 24,
	[17][4] = 28,
	[19][3] = 31,
	[21][4] = 34,
	[22][1] = 35,
	[25][1] = 41,
	[26][2] = 42,
	[29][1] = 43,
	[32][2] = 44,
	[35][3] = 45,
	[39][1] = 47,
	[40][2] = 49,
	[42][4] = 50,
	[43][3] = 51,
	[44][4] = 52,
	[47][3] = 55,
	[49][4] = 58,
	[53][1] = 59,
	[56][2] = 60,
	[59][3] = 61,
	[60][4] = 62,
};


const unsigned zebu_lexer[55][256] = {
	[1][34] = 9,
	[1][48] = 10,
	[1][49] = 10,
	[1][50] = 10,
	[1][51] = 10,
	[1][52] = 10,
	[1][53] = 10,
	[1][54] = 10,
	[1][55] = 10,
	[1][56] = 10,
	[1][57] = 10,
	[1][91] = 11,
	[1][123] = 12,
	[3][34] = 14,
	[3][48] = 15,
	[3][49] = 15,
	[3][50] = 15,
	[3][51] = 15,
	[3][52] = 15,
	[3][53] = 15,
	[3][54] = 15,
	[3][55] = 15,
	[3][56] = 15,
	[3][57] = 15,
	[3][91] = 16,
	[3][93] = 17,
	[3][123] = 18,
	[4][34] = 19,
	[4][125] = 20,
	[5][44] = 21,
	[5][93] = 22,
	[6][58] = 23,
	[7][44] = 24,
	[7][125] = 25,
	[8][34] = 26,
	[9][0] = 9,
	[9][1] = 9,
	[9][2] = 9,
	[9][3] = 9,
	[9][4] = 9,
	[9][5] = 9,
	[9][6] = 9,
	[9][7] = 9,
	[9][8] = 9,
	[9][9] = 9,
	[9][10] = 9,
	[9][11] = 9,
	[9][12] = 9,
	[9][13] = 9,
	[9][14] = 9,
	[9][15] = 9,
	[9][16] = 9,
	[9][17] = 9,
	[9][18] = 9,
	[9][19] = 9,
	[9][20] = 9,
	[9][21] = 9,
	[9][22] = 9,
	[9][23] = 9,
	[9][24] = 9,
	[9][25] = 9,
	[9][26] = 9,
	[9][27] = 9,
	[9][28] = 9,
	[9][29] = 9,
	[9][30] = 9,
	[9][31] = 9,
	[9][32] = 9,
	[9][33] = 9,
	[9][34] = 27,
	[9][35] = 9,
	[9][36] = 9,
	[9][37] = 9,
	[9][38] = 9,
	[9][39] = 9,
	[9][40] = 9,
	[9][41] = 9,
	[9][42] = 9,
	[9][43] = 9,
	[9][44] = 9,
	[9][45] = 9,
	[9][46] = 9,
	[9][47] = 9,
	[9][48] = 9,
	[9][49] = 9,
	[9][50] = 9,
	[9][51] = 9,
	[9][52] = 9,
	[9][53] = 9,
	[9][54] = 9,
	[9][55] = 9,
	[9][56] = 9,
	[9][57] = 9,
	[9][58] = 9,
	[9][59] = 9,
	[9][60] = 9,
	[9][61] = 9,
	[9][62] = 9,
	[9][63] = 9,
	[9][64] = 9,
	[9][65] = 9,
	[9][66] = 9,
	[9][67] = 9,
	[9][68] = 9,
	[9][69] = 9,
	[9][70] = 9,
	[9][71] = 9,
	[9][72] = 9,
	[9][73] = 9,
	[9][74] = 9,
	[9][75] = 9,
	[9][76] = 9,
	[9][77] = 9,
	[9][78] = 9,
	[9][79] = 9,
	[9][80] = 9,
	[9][81] = 9,
	[9][82] = 9,
	[9][83] = 9,
	[9][84] = 9,
	[9][85] = 9,
	[9][86] = 9,
	[9][87] = 9,
	[9][88] = 9,
	[9][89] = 9,
	[9][90] = 9,
	[9][91] = 9,
	[9][92] = 28,
	[9][93] = 9,
	[9][94] = 9,
	[9][95] = 9,
	[9][96] = 9,
	[9][97] = 9,
	[9][98] = 9,
	[9][99] = 9,
	[9][100] = 9,
	[9][101] = 9,
	[9][102] = 9,
	[9][103] = 9,
	[9][104] = 9,
	[9][105] = 9,
	[9][106] = 9,
	[9][107] = 9,
	[9][108] = 9,
	[9][109] = 9,
	[9][110] = 9,
	[9][111] = 9,
	[9][112] = 9,
	[9][113] = 9,
	[9][114] = 9,
	[9][115] = 9,
	[9][116] = 9,
	[9][117] = 9,
	[9][118] = 9,
	[9][119] = 9,
	[9][120] = 9,
	[9][121] = 9,
	[9][122] = 9,
	[9][123] = 9,
	[9][124] = 9,
	[9][125] = 9,
	[9][126] = 9,
	[9][127] = 9,
	[9][128] = 9,
	[9][129] = 9,
	[9][130] = 9,
	[9][131] = 9,
	[9][132] = 9,
	[9][133] = 9,
	[9][134] = 9,
	[9][135] = 9,
	[9][136] = 9,
	[9][137] = 9,
	[9][138] = 9,
	[9][139] = 9,
	[9][140] = 9,
	[9][141] = 9,
	[9][142] = 9,
	[9][143] = 9,
	[9][144] = 9,
	[9][145] = 9,
	[9][146] = 9,
	[9][147] = 9,
	[9][148] = 9,
	[9][149] = 9,
	[9][150] = 9,
	[9][151] = 9,
	[9][152] = 9,
	[9][153] = 9,
	[9][154] = 9,
	[9][155] = 9,
	[9][156] = 9,
	[9][157] = 9,
	[9][158] = 9,
	[9][159] = 9,
	[9][160] = 9,
	[9][161] = 9,
	[9][162] = 9,
	[9][163] = 9,
	[9][164] = 9,
	[9][165] = 9,
	[9][166] = 9,
	[9][167] = 9,
	[9][168] = 9,
	[9][169] = 9,
	[9][170] = 9,
	[9][171] = 9,
	[9][172] = 9,
	[9][173] = 9,
	[9][174] = 9,
	[9][175] = 9,
	[9][176] = 9,
	[9][177] = 9,
	[9][178] = 9,
	[9][179] = 9,
	[9][180] = 9,
	[9][181] = 9,
	[9][182] = 9,
	[9][183] = 9,
	[9][184] = 9,
	[9][185] = 9,
	[9][186] = 9,
	[9][187] = 9,
	[9][188] = 9,
	[9][189] = 9,
	[9][190] = 9,
	[9][191] = 9,
	[9][192] = 9,
	[9][193] = 9,
	[9][194] = 9,
	[9][195] = 9,
	[9][196] = 9,
	[9][197] = 9,
	[9][198] = 9,
	[9][199] = 9,
	[9][200] = 9,
	[9][201] = 9,
	[9][202] = 9,
	[9][203] = 9,
	[9][204] = 9,
	[9][205] = 9,
	[9][206] = 9,
	[9][207] = 9,
	[9][208] = 9,
	[9][209] = 9,
	[9][210] = 9,
	[9][211] = 9,
	[9][212] = 9,
	[9][213] = 9,
	[9][214] = 9,
	[9][215] = 9,
	[9][216] = 9,
	[9][217] = 9,
	[9][218] = 9,
	[9][219] = 9,
	[9][220] = 9,
	[9][221] = 9,
	[9][222] = 9,
	[9][223] = 9,
	[9][224] = 9,
	[9][225] = 9,
	[9][226] = 9,
	[9][227] = 9,
	[9][228] = 9,
	[9][229] = 9,
	[9][230] = 9,
	[9][231] = 9,
	[9][232] = 9,
	[9][233] = 9,
	[9][234] = 9,
	[9][235] = 9,
	[9][236] = 9,
	[9][237] = 9,
	[9][238] = 9,
	[9][239] = 9,
	[9][240] = 9,
	[9][241] = 9,
	[9][242] = 9,
	[9][243] = 9,
	[9][244] = 9,
	[9][245] = 9,
	[9][246] = 9,
	[9][247] = 9,
	[9][248] = 9,
	[9][249] = 9,
	[9][250] = 9,
	[9][251] = 9,
	[9][252] = 9,
	[9][253] = 9,
	[9][254] = 9,
	[9][255] = 9,
	[10][46] = 29,
	[10][48] = 10,
	[10][49] = 10,
	[10][50] = 10,
	[10][51] = 10,
	[10][52] = 10,
	[10][53] = 10,
	[10][54] = 10,
	[10][55] = 10,
	[10][56] = 10,
	[10][57] = 10,
	[14][0] = 14,
	[14][1] = 14,
	[14][2] = 14,
	[14][3] = 14,
	[14][4] = 14,
	[14][5] = 14,
	[14][6] = 14,
	[14][7] = 14,
	[14][8] = 14,
	[14][9] = 14,
	[14][10] = 14,
	[14][11] = 14,
	[14][12] = 14,
	[14][13] = 14,
	[14][14] = 14,
	[14][15] = 14,
	[14][16] = 14,
	[14][17] = 14,
	[14][18] = 14,
	[14][19] = 14,
	[14][20] = 14,
	[14][21] = 14,
	[14][22] = 14,
	[14][23] = 14,
	[14][24] = 14,
	[14][25] = 14,
	[14][26] = 14,
	[14][27] = 14,
	[14][28] = 14,
	[14][29] = 14,
	[14][30] = 14,
	[14][31] = 14,
	[14][32] = 14,
	[14][33] = 14,
	[14][34] = 30,
	[14][35] = 14,
	[14][36] = 14,
	[14][37] = 14,
	[14][38] = 14,
	[14][39] = 14,
	[14][40] = 14,
	[14][41] = 14,
	[14][42] = 14,
	[14][43] = 14,
	[14][44] = 14,
	[14][45] = 14,
	[14][46] = 14,
	[14][47] = 14,
	[14][48] = 14,
	[14][49] = 14,
	[14][50] = 14,
	[14][51] = 14,
	[14][52] = 14,
	[14][53] = 14,
	[14][54] = 14,
	[14][55] = 14,
	[14][56] = 14,
	[14][57] = 14,
	[14][58] = 14,
	[14][59] = 14,
	[14][60] = 14,
	[14][61] = 14,
	[14][62] = 14,
	[14][63] = 14,
	[14][64] = 14,
	[14][65] = 14,
	[14][66] = 14,
	[14][67] = 14,
	[14][68] = 14,
	[14][69] = 14,
	[14][70] = 14,
	[14][71] = 14,
	[14][72] = 14,
	[14][73] = 14,
	[14][74] = 14,
	[14][75] = 14,
	[14][76] = 14,
	[14][77] = 14,
	[14][78] = 14,
	[14][79] = 14,
	[14][80] = 14,
	[14][81] = 14,
	[14][82] = 14,
	[14][83] = 14,
	[14][84] = 14,
	[14][85] = 14,
	[14][86] = 14,
	[14][87] = 14,
	[14][88] = 14,
	[14][89] = 14,
	[14][90] = 14,
	[14][91] = 14,
	[14][92] = 31,
	[14][93] = 14,
	[14][94] = 14,
	[14][95] = 14,
	[14][96] = 14,
	[14][97] = 14,
	[14][98] = 14,
	[14][99] = 14,
	[14][100] = 14,
	[14][101] = 14,
	[14][102] = 14,
	[14][103] = 14,
	[14][104] = 14,
	[14][105] = 14,
	[14][106] = 14,
	[14][107] = 14,
	[14][108] = 14,
	[14][109] = 14,
	[14][110] = 14,
	[14][111] = 14,
	[14][112] = 14,
	[14][113] = 14,
	[14][114] = 14,
	[14][115] = 14,
	[14][116] = 14,
	[14][117] = 14,
	[14][118] = 14,
	[14][119] = 14,
	[14][120] = 14,
	[14][121] = 14,
	[14][122] = 14,
	[14][123] = 14,
	[14][124] = 14,
	[14][125] = 14,
	[14][126] = 14,
	[14][127] = 14,
	[14][128] = 14,
	[14][129] = 14,
	[14][130] = 14,
	[14][131] = 14,
	[14][132] = 14,
	[14][133] = 14,
	[14][134] = 14,
	[14][135] = 14,
	[14][136] = 14,
	[14][137] = 14,
	[14][138] = 14,
	[14][139] = 14,
	[14][140] = 14,
	[14][141] = 14,
	[14][142] = 14,
	[14][143] = 14,
	[14][144] = 14,
	[14][145] = 14,
	[14][146] = 14,
	[14][147] = 14,
	[14][148] = 14,
	[14][149] = 14,
	[14][150] = 14,
	[14][151] = 14,
	[14][152] = 14,
	[14][153] = 14,
	[14][154] = 14,
	[14][155] = 14,
	[14][156] = 14,
	[14][157] = 14,
	[14][158] = 14,
	[14][159] = 14,
	[14][160] = 14,
	[14][161] = 14,
	[14][162] = 14,
	[14][163] = 14,
	[14][164] = 14,
	[14][165] = 14,
	[14][166] = 14,
	[14][167] = 14,
	[14][168] = 14,
	[14][169] = 14,
	[14][170] = 14,
	[14][171] = 14,
	[14][172] = 14,
	[14][173] = 14,
	[14][174] = 14,
	[14][175] = 14,
	[14][176] = 14,
	[14][177] = 14,
	[14][178] = 14,
	[14][179] = 14,
	[14][180] = 14,
	[14][181] = 14,
	[14][182] = 14,
	[14][183] = 14,
	[14][184] = 14,
	[14][185] = 14,
	[14][186] = 14,
	[14][187] = 14,
	[14][188] = 14,
	[14][189] = 14,
	[14][190] = 14,
	[14][191] = 14,
	[14][192] = 14,
	[14][193] = 14,
	[14][194] = 14,
	[14][195] = 14,
	[14][196] = 14,
	[14][197] = 14,
	[14][198] = 14,
	[14][199] = 14,
	[14][200] = 14,
	[14][201] = 14,
	[14][202] = 14,
	[14][203] = 14,
	[14][204] = 14,
	[14][205] = 14,
	[14][206] = 14,
	[14][207] = 14,
	[14][208] = 14,
	[14][209] = 14,
	[14][210] = 14,
	[14][211] = 14,
	[14][212] = 14,
	[14][213] = 14,
	[14][214] = 14,
	[14][215] = 14,
	[14][216] = 14,
	[14][217] = 14,
	[14][218] = 14,
	[14][219] = 14,
	[14][220] = 14,
	[14][221] = 14,
	[14][222] = 14,
	[14][223] = 14,
	[14][224] = 14,
	[14][225] = 14,
	[14][226] = 14,
	[14][227] = 14,
	[14][228] = 14,
	[14][229] = 14,
	[14][230] = 14,
	[14][231] = 14,
	[14][232] = 14,
	[14][233] = 14,
	[14][234] = 14,
	[14][235] = 14,
	[14][236] = 14,
	[14][237] = 14,
	[14][238] = 14,
	[14][239] = 14,
	[14][240] = 14,
	[14][241] = 14,
	[14][242] = 14,
	[14][243] = 14,
	[14][244] = 14,
	[14][245] = 14,
	[14][246] = 14,
	[14][247] = 14,
	[14][248] = 14,
	[14][249] = 14,
	[14][250] = 14,
	[14][251] = 14,
	[14][252] = 14,
	[14][253] = 14,
	[14][254] = 14,
	[14][255] = 14,
	[15][46] = 32,
	[15][48] = 15,
	[15][49] = 15,
	[15][50] = 15,
	[15][51] = 15,
	[15][52] = 15,
	[15][53] = 15,
	[15][54] = 15,
	[15][55] = 15,
	[15][56] = 15,
	[15][57] = 15,
	[19][0] = 19,
	[19][1] = 19,
	[19][2] = 19,
	[19][3] = 19,
	[19][4] = 19,
	[19][5] = 19,
	[19][6] = 19,
	[19][7] = 19,
	[19][8] = 19,
	[19][9] = 19,
	[19][10] = 19,
	[19][11] = 19,
	[19][12] = 19,
	[19][13] = 19,
	[19][14] = 19,
	[19][15] = 19,
	[19][16] = 19,
	[19][17] = 19,
	[19][18] = 19,
	[19][19] = 19,
	[19][20] = 19,
	[19][21] = 19,
	[19][22] = 19,
	[19][23] = 19,
	[19][24] = 19,
	[19][25] = 19,
	[19][26] = 19,
	[19][27] = 19,
	[19][28] = 19,
	[19][29] = 19,
	[19][30] = 19,
	[19][31] = 19,
	[19][32] = 19,
	[19][33] = 19,
	[19][34] = 33,
	[19][35] = 19,
	[19][36] = 19,
	[19][37] = 19,
	[19][38] = 19,
	[19][39] = 19,
	[19][40] = 19,
	[19][41] = 19,
	[19][42] = 19,
	[19][43] = 19,
	[19][44] = 19,
	[19][45] = 19,
	[19][46] = 19,
	[19][47] = 19,
	[19][48] = 19,
	[19][49] = 19,
	[19][50] = 19,
	[19][51] = 19,
	[19][52] = 19,
	[19][53] = 19,
	[19][54] = 19,
	[19][55] = 19,
	[19][56] = 19,
	[19][57] = 19,
	[19][58] = 19,
	[19][59] = 19,
	[19][60] = 19,
	[19][61] = 19,
	[19][62] = 19,
	[19][63] = 19,
	[19][64] = 19,
	[19][65] = 19,
	[19][66] = 19,
	[19][67] = 19,
	[19][68] = 19,
	[19][69] = 19,
	[19][70] = 19,
	[19][71] = 19,
	[19][72] = 19,
	[19][73] = 19,
	[19][74] = 19,
	[19][75] = 19,
	[19][76] = 19,
	[19][77] = 19,
	[19][78] = 19,
	[19][79] = 19,
	[19][80] = 19,
	[19][81] = 19,
	[19][82] = 19,
	[19][83] = 19,
	[19][84] = 19,
	[19][85] = 19,
	[19][86] = 19,
	[19][87] = 19,
	[19][88] = 19,
	[19][89] = 19,
	[19][90] = 19,
	[19][91] = 19,
	[19][92] = 34,
	[19][93] = 19,
	[19][94] = 19,
	[19][95] = 19,
	[19][96] = 19,
	[19][97] = 19,
	[19][98] = 19,
	[19][99] = 19,
	[19][100] = 19,
	[19][101] = 19,
	[19][102] = 19,
	[19][103] = 19,
	[19][104] = 19,
	[19][105] = 19,
	[19][106] = 19,
	[19][107] = 19,
	[19][108] = 19,
	[19][109] = 19,
	[19][110] = 19,
	[19][111] = 19,
	[19][112] = 19,
	[19][113] = 19,
	[19][114] = 19,
	[19][115] = 19,
	[19][116] = 19,
	[19][117] = 19,
	[19][118] = 19,
	[19][119] = 19,
	[19][120] = 19,
	[19][121] = 19,
	[19][122] = 19,
	[19][123] = 19,
	[19][124] = 19,
	[19][125] = 19,
	[19][126] = 19,
	[19][127] = 19,
	[19][128] = 19,
	[19][129] = 19,
	[19][130] = 19,
	[19][131] = 19,
	[19][132] = 19,
	[19][133] = 19,
	[19][134] = 19,
	[19][135] = 19,
	[19][136] = 19,
	[19][137] = 19,
	[19][138] = 19,
	[19][139] = 19,
	[19][140] = 19,
	[19][141] = 19,
	[19][142] = 19,
	[19][143] = 19,
	[19][144] = 19,
	[19][145] = 19,
	[19][146] = 19,
	[19][147] = 19,
	[19][148] = 19,
	[19][149] = 19,
	[19][150] = 19,
	[19][151] = 19,
	[19][152] = 19,
	[19][153] = 19,
	[19][154] = 19,
	[19][155] = 19,
	[19][156] = 19,
	[19][157] = 19,
	[19][158] = 19,
	[19][159] = 19,
	[19][160] = 19,
	[19][161] = 19,
	[19][162] = 19,
	[19][163] = 19,
	[19][164] = 19,
	[19][165] = 19,
	[19][166] = 19,
	[19][167] = 19,
	[19][168] = 19,
	[19][169] = 19,
	[19][170] = 19,
	[19][171] = 19,
	[19][172] = 19,
	[19][173] = 19,
	[19][174] = 19,
	[19][175] = 19,
	[19][176] = 19,
	[19][177] = 19,
	[19][178] = 19,
	[19][179] = 19,
	[19][180] = 19,
	[19][181] = 19,
	[19][182] = 19,
	[19][183] = 19,
	[19][184] = 19,
	[19][185] = 19,
	[19][186] = 19,
	[19][187] = 19,
	[19][188] = 19,
	[19][189] = 19,
	[19][190] = 19,
	[19][191] = 19,
	[19][192] = 19,
	[19][193] = 19,
	[19][194] = 19,
	[19][195] = 19,
	[19][196] = 19,
	[19][197] = 19,
	[19][198] = 19,
	[19][199] = 19,
	[19][200] = 19,
	[19][201] = 19,
	[19][202] = 19,
	[19][203] = 19,
	[19][204] = 19,
	[19][205] = 19,
	[19][206] = 19,
	[19][207] = 19,
	[19][208] = 19,
	[19][209] = 19,
	[19][210] = 19,
	[19][211] = 19,
	[19][212] = 19,
	[19][213] = 19,
	[19][214] = 19,
	[19][215] = 19,
	[19][216] = 19,
	[19][217] = 19,
	[19][218] = 19,
	[19][219] = 19,
	[19][220] = 19,
	[19][221] = 19,
	[19][222] = 19,
	[19][223] = 19,
	[19][224] = 19,
	[19][225] = 19,
	[19][226] = 19,
	[19][227] = 19,
	[19][228] = 19,
	[19][229] = 19,
	[19][230] = 19,
	[19][231] = 19,
	[19][232] = 19,
	[19][233] = 19,
	[19][234] = 19,
	[19][235] = 19,
	[19][236] = 19,
	[19][237] = 19,
	[19][238] = 19,
	[19][239] = 19,
	[19][240] = 19,
	[19][241] = 19,
	[19][242] = 19,
	[19][243] = 19,
	[19][244] = 19,
	[19][245] = 19,
	[19][246] = 19,
	[19][247] = 19,
	[19][248] = 19,
	[19][249] = 19,
	[19][250] = 19,
	[19][251] = 19,
	[19][252] = 19,
	[19][253] = 19,
	[19][254] = 19,
	[19][255] = 19,
	[26][0] = 26,
	[26][1] = 26,
	[26][2] = 26,
	[26][3] = 26,
	[26][4] = 26,
	[26][5] = 26,
	[26][6] = 26,
	[26][7] = 26,
	[26][8] = 26,
	[26][9] = 26,
	[26][10] = 26,
	[26][11] = 26,
	[26][12] = 26,
	[26][13] = 26,
	[26][14] = 26,
	[26][15] = 26,
	[26][16] = 26,
	[26][17] = 26,
	[26][18] = 26,
	[26][19] = 26,
	[26][20] = 26,
	[26][21] = 26,
	[26][22] = 26,
	[26][23] = 26,
	[26][24] = 26,
	[26][25] = 26,
	[26][26] = 26,
	[26][27] = 26,
	[26][28] = 26,
	[26][29] = 26,
	[26][30] = 26,
	[26][31] = 26,
	[26][32] = 26,
	[26][33] = 26,
	[26][34] = 35,
	[26][35] = 26,
	[26][36] = 26,
	[26][37] = 26,
	[26][38] = 26,
	[26][39] = 26,
	[26][40] = 26,
	[26][41] = 26,
	[26][42] = 26,
	[26][43] = 26,
	[26][44] = 26,
	[26][45] = 26,
	[26][46] = 26,
	[26][47] = 26,
	[26][48] = 26,
	[26][49] = 26,
	[26][50] = 26,
	[26][51] = 26,
	[26][52] = 26,
	[26][53] = 26,
	[26][54] = 26,
	[26][55] = 26,
	[26][56] = 26,
	[26][57] = 26,
	[26][58] = 26,
	[26][59] = 26,
	[26][60] = 26,
	[26][61] = 26,
	[26][62] = 26,
	[26][63] = 26,
	[26][64] = 26,
	[26][65] = 26,
	[26][66] = 26,
	[26][67] = 26,
	[26][68] = 26,
	[26][69] = 26,
	[26][70] = 26,
	[26][71] = 26,
	[26][72] = 26,
	[26][73] = 26,
	[26][74] = 26,
	[26][75] = 26,
	[26][76] = 26,
	[26][77] = 26,
	[26][78] = 26,
	[26][79] = 26,
	[26][80] = 26,
	[26][81] = 26,
	[26][82] = 26,
	[26][83] = 26,
	[26][84] = 26,
	[26][85] = 26,
	[26][86] = 26,
	[26][87] = 26,
	[26][88] = 26,
	[26][89] = 26,
	[26][90] = 26,
	[26][91] = 26,
	[26][92] = 36,
	[26][93] = 26,
	[26][94] = 26,
	[26][95] = 26,
	[26][96] = 26,
	[26][97] = 26,
	[26][98] = 26,
	[26][99] = 26,
	[26][100] = 26,
	[26][101] = 26,
	[26][102] = 26,
	[26][103] = 26,
	[26][104] = 26,
	[26][105] = 26,
	[26][106] = 26,
	[26][107] = 26,
	[26][108] = 26,
	[26][109] = 26,
	[26][110] = 26,
	[26][111] = 26,
	[26][112] = 26,
	[26][113] = 26,
	[26][114] = 26,
	[26][115] = 26,
	[26][116] = 26,
	[26][117] = 26,
	[26][118] = 26,
	[26][119] = 26,
	[26][120] = 26,
	[26][121] = 26,
	[26][122] = 26,
	[26][123] = 26,
	[26][124] = 26,
	[26][125] = 26,
	[26][126] = 26,
	[26][127] = 26,
	[26][128] = 26,
	[26][129] = 26,
	[26][130] = 26,
	[26][131] = 26,
	[26][132] = 26,
	[26][133] = 26,
	[26][134] = 26,
	[26][135] = 26,
	[26][136] = 26,
	[26][137] = 26,
	[26][138] = 26,
	[26][139] = 26,
	[26][140] = 26,
	[26][141] = 26,
	[26][142] = 26,
	[26][143] = 26,
	[26][144] = 26,
	[26][145] = 26,
	[26][146] = 26,
	[26][147] = 26,
	[26][148] = 26,
	[26][149] = 26,
	[26][150] = 26,
	[26][151] = 26,
	[26][152] = 26,
	[26][153] = 26,
	[26][154] = 26,
	[26][155] = 26,
	[26][156] = 26,
	[26][157] = 26,
	[26][158] = 26,
	[26][159] = 26,
	[26][160] = 26,
	[26][161] = 26,
	[26][162] = 26,
	[26][163] = 26,
	[26][164] = 26,
	[26][165] = 26,
	[26][166] = 26,
	[26][167] = 26,
	[26][168] = 26,
	[26][169] = 26,
	[26][170] = 26,
	[26][171] = 26,
	[26][172] = 26,
	[26][173] = 26,
	[26][174] = 26,
	[26][175] = 26,
	[26][176] = 26,
	[26][177] = 26,
	[26][178] = 26,
	[26][179] = 26,
	[26][180] = 26,
	[26][181] = 26,
	[26][182] = 26,
	[26][183] = 26,
	[26][184] = 26,
	[26][185] = 26,
	[26][186] = 26,
	[26][187] = 26,
	[26][188] = 26,
	[26][189] = 26,
	[26][190] = 26,
	[26][191] = 26,
	[26][192] = 26,
	[26][193] = 26,
	[26][194] = 26,
	[26][195] = 26,
	[26][196] = 26,
	[26][197] = 26,
	[26][198] = 26,
	[26][199] = 26,
	[26][200] = 26,
	[26][201] = 26,
	[26][202] = 26,
	[26][203] = 26,
	[26][204] = 26,
	[26][205] = 26,
	[26][206] = 26,
	[26][207] = 26,
	[26][208] = 26,
	[26][209] = 26,
	[26][210] = 26,
	[26][211] = 26,
	[26][212] = 26,
	[26][213] = 26,
	[26][214] = 26,
	[26][215] = 26,
	[26][216] = 26,
	[26][217] = 26,
	[26][218] = 26,
	[26][219] = 26,
	[26][220] = 26,
	[26][221] = 26,
	[26][222] = 26,
	[26][223] = 26,
	[26][224] = 26,
	[26][225] = 26,
	[26][226] = 26,
	[26][227] = 26,
	[26][228] = 26,
	[26][229] = 26,
	[26][230] = 26,
	[26][231] = 26,
	[26][232] = 26,
	[26][233] = 26,
	[26][234] = 26,
	[26][235] = 26,
	[26][236] = 26,
	[26][237] = 26,
	[26][238] = 26,
	[26][239] = 26,
	[26][240] = 26,
	[26][241] = 26,
	[26][242] = 26,
	[26][243] = 26,
	[26][244] = 26,
	[26][245] = 26,
	[26][246] = 26,
	[26][247] = 26,
	[26][248] = 26,
	[26][249] = 26,
	[26][250] = 26,
	[26][251] = 26,
	[26][252] = 26,
	[26][253] = 26,
	[26][254] = 26,
	[26][255] = 26,
	[28][34] = 9,
	[28][92] = 9,
	[28][117] = 37,
	[29][48] = 38,
	[29][49] = 38,
	[29][50] = 38,
	[29][51] = 38,
	[29][52] = 38,
	[29][53] = 38,
	[29][54] = 38,
	[29][55] = 38,
	[29][56] = 38,
	[29][57] = 38,
	[31][34] = 14,
	[31][92] = 14,
	[31][117] = 39,
	[32][48] = 40,
	[32][49] = 40,
	[32][50] = 40,
	[32][51] = 40,
	[32][52] = 40,
	[32][53] = 40,
	[32][54] = 40,
	[32][55] = 40,
	[32][56] = 40,
	[32][57] = 40,
	[34][34] = 19,
	[34][92] = 19,
	[34][117] = 41,
	[36][34] = 26,
	[36][92] = 26,
	[36][117] = 42,
	[37][48] = 43,
	[37][49] = 43,
	[37][50] = 43,
	[37][51] = 43,
	[37][52] = 43,
	[37][53] = 43,
	[37][54] = 43,
	[37][55] = 43,
	[37][56] = 43,
	[37][57] = 43,
	[37][97] = 43,
	[37][98] = 43,
	[37][99] = 43,
	[37][100] = 43,
	[37][101] = 43,
	[37][102] = 43,
	[38][48] = 38,
	[38][49] = 38,
	[38][50] = 38,
	[38][51] = 38,
	[38][52] = 38,
	[38][53] = 38,
	[38][54] = 38,
	[38][55] = 38,
	[38][56] = 38,
	[38][57] = 38,
	[39][48] = 44,
	[39][49] = 44,
	[39][50] = 44,
	[39][51] = 44,
	[39][52] = 44,
	[39][53] = 44,
	[39][54] = 44,
	[39][55] = 44,
	[39][56] = 44,
	[39][57] = 44,
	[39][97] = 44,
	[39][98] = 44,
	[39][99] = 44,
	[39][100] = 44,
	[39][101] = 44,
	[39][102] = 44,
	[40][48] = 40,
	[40][49] = 40,
	[40][50] = 40,
	[40][51] = 40,
	[40][52] = 40,
	[40][53] = 40,
	[40][54] = 40,
	[40][55] = 40,
	[40][56] = 40,
	[40][57] = 40,
	[41][48] = 45,
	[41][49] = 45,
	[41][50] = 45,
	[41][51] = 45,
	[41][52] = 45,
	[41][53] = 45,
	[41][54] = 45,
	[41][55] = 45,
	[41][56] = 45,
	[41][57] = 45,
	[41][97] = 45,
	[41][98] = 45,
	[41][99] = 45,
	[41][100] = 45,
	[41][101] = 45,
	[41][102] = 45,
	[42][48] = 46,
	[42][49] = 46,
	[42][50] = 46,
	[42][51] = 46,
	[42][52] = 46,
	[42][53] = 46,
	[42][54] = 46,
	[42][55] = 46,
	[42][56] = 46,
	[42][57] = 46,
	[42][97] = 46,
	[42][98] = 46,
	[42][99] = 46,
	[42][100] = 46,
	[42][101] = 46,
	[42][102] = 46,
	[43][48] = 47,
	[43][49] = 47,
	[43][50] = 47,
	[43][51] = 47,
	[43][52] = 47,
	[43][53] = 47,
	[43][54] = 47,
	[43][55] = 47,
	[43][56] = 47,
	[43][57] = 47,
	[43][97] = 47,
	[43][98] = 47,
	[43][99] = 47,
	[43][100] = 47,
	[43][101] = 47,
	[43][102] = 47,
	[44][48] = 48,
	[44][49] = 48,
	[44][50] = 48,
	[44][51] = 48,
	[44][52] = 48,
	[44][53] = 48,
	[44][54] = 48,
	[44][55] = 48,
	[44][56] = 48,
	[44][57] = 48,
	[44][97] = 48,
	[44][98] = 48,
	[44][99] = 48,
	[44][100] = 48,
	[44][101] = 48,
	[44][102] = 48,
	[45][48] = 49,
	[45][49] = 49,
	[45][50] = 49,
	[45][51] = 49,
	[45][52] = 49,
	[45][53] = 49,
	[45][54] = 49,
	[45][55] = 49,
	[45][56] = 49,
	[45][57] = 49,
	[45][97] = 49,
	[45][98] = 49,
	[45][99] = 49,
	[45][100] = 49,
	[45][101] = 49,
	[45][102] = 49,
	[46][48] = 50,
	[46][49] = 50,
	[46][50] = 50,
	[46][51] = 50,
	[46][52] = 50,
	[46][53] = 50,
	[46][54] = 50,
	[46][55] = 50,
	[46][56] = 50,
	[46][57] = 50,
	[46][97] = 50,
	[46][98] = 50,
	[46][99] = 50,
	[46][100] = 50,
	[46][101] = 50,
	[46][102] = 50,
	[47][48] = 51,
	[47][49] = 51,
	[47][50] = 51,
	[47][51] = 51,
	[47][52] = 51,
	[47][53] = 51,
	[47][54] = 51,
	[47][55] = 51,
	[47][56] = 51,
	[47][57] = 51,
	[47][97] = 51,
	[47][98] = 51,
	[47][99] = 51,
	[47][100] = 51,
	[47][101] = 51,
	[47][102] = 51,
	[48][48] = 52,
	[48][49] = 52,
	[48][50] = 52,
	[48][51] = 52,
	[48][52] = 52,
	[48][53] = 52,
	[48][54] = 52,
	[48][55] = 52,
	[48][56] = 52,
	[48][57] = 52,
	[48][97] = 52,
	[48][98] = 52,
	[48][99] = 52,
	[48][100] = 52,
	[48][101] = 52,
	[48][102] = 52,
	[49][48] = 53,
	[49][49] = 53,
	[49][50] = 53,
	[49][51] = 53,
	[49][52] = 53,
	[49][53] = 53,
	[49][54] = 53,
	[49][55] = 53,
	[49][56] = 53,
	[49][57] = 53,
	[49][97] = 53,
	[49][98] = 53,
	[49][99] = 53,
	[49][100] = 53,
	[49][101] = 53,
	[49][102] = 53,
	[50][48] = 54,
	[50][49] = 54,
	[50][50] = 54,
	[50][51] = 54,
	[50][52] = 54,
	[50][53] = 54,
	[50][54] = 54,
	[50][55] = 54,
	[50][56] = 54,
	[50][57] = 54,
	[50][97] = 54,
	[50][98] = 54,
	[50][99] = 54,
	[50][100] = 54,
	[50][101] = 54,
	[50][102] = 54,
	[51][48] = 9,
	[51][49] = 9,
	[51][50] = 9,
	[51][51] = 9,
	[51][52] = 9,
	[51][53] = 9,
	[51][54] = 9,
	[51][55] = 9,
	[51][56] = 9,
	[51][57] = 9,
	[51][97] = 9,
	[51][98] = 9,
	[51][99] = 9,
	[51][100] = 9,
	[51][101] = 9,
	[51][102] = 9,
	[52][48] = 14,
	[52][49] = 14,
	[52][50] = 14,
	[52][51] = 14,
	[52][52] = 14,
	[52][53] = 14,
	[52][54] = 14,
	[52][55] = 14,
	[52][56] = 14,
	[52][57] = 14,
	[52][97] = 14,
	[52][98] = 14,
	[52][99] = 14,
	[52][100] = 14,
	[52][101] = 14,
	[52][102] = 14,
	[53][48] = 19,
	[53][49] = 19,
	[53][50] = 19,
	[53][51] = 19,
	[53][52] = 19,
	[53][53] = 19,
	[53][54] = 19,
	[53][55] = 19,
	[53][56] = 19,
	[53][57] = 19,
	[53][97] = 19,
	[53][98] = 19,
	[53][99] = 19,
	[53][100] = 19,
	[53][101] = 19,
	[53][102] = 19,
	[54][48] = 26,
	[54][49] = 26,
	[54][50] = 26,
	[54][51] = 26,
	[54][52] = 26,
	[54][53] = 26,
	[54][54] = 26,
	[54][55] = 26,
	[54][56] = 26,
	[54][57] = 26,
	[54][97] = 26,
	[54][98] = 26,
	[54][99] = 26,
	[54][100] = 26,
	[54][101] = 26,
	[54][102] = 26,
};


const unsigned zebu_lexer_starts[63] = {
	[1] = 1,
	[2] = 2,
	[3] = 2,
	[4] = 2,
	[5] = 3,
	[6] = 4,
	[7] = 2,
	[8] = 5,
	[9] = 5,
	[10] = 5,
	[11] = 3,
	[12] = 2,
	[13] = 4,
	[14] = 5,
	[15] = 6,
	[16] = 2,
	[17] = 7,
	[18] = 5,
	[19] = 5,
	[20] = 5,
	[21] = 7,
	[22] = 1,
	[23] = 2,
	[24] = 2,
	[25] = 1,
	[26] = 8,
	[27] = 2,
	[28] = 2,
	[29] = 1,
	[30] = 5,
	[31] = 5,
	[32] = 8,
	[33] = 5,
	[34] = 5,
	[35] = 5,
	[36] = 7,
	[37] = 7,
	[38] = 7,
	[39] = 3,
	[40] = 4,
	[41] = 7,
	[42] = 7,
	[43] = 5,
	[44] = 7,
	[45] = 2,
	[46] = 7,
	[47] = 5,
	[48] = 7,
	[49] = 7,
	[50] = 2,
	[51] = 5,
	[52] = 5,
	[53] = 1,
	[54] = 7,
	[55] = 7,
	[56] = 8,
	[57] = 7,
	[58] = 7,
	[59] = 5,
	[60] = 7,
	[61] = 7,
	[62] = 7,
};


const unsigned zebu_lexer_accepts[41] = {
	[10] = 3,
	[11] = 5,
	[12] = 6,
	[13] = 7,
	[15] = 3,
	[16] = 5,
	[17] = 8,
	[18] = 6,
	[20] = 9,
	[21] = 10,
	[22] = 8,
	[23] = 11,
	[24] = 10,
	[25] = 9,
	[27] = 2,
	[30] = 2,
	[33] = 2,
	[35] = 2,
	[38] = 4,
	[40] = 4,
};


const unsigned zebu_lexer_EOFs[3] = {
	[2] = 13,
};


#ifdef ZEBU_DEBUG
#include <stdbool.h>

struct link
{
	bool is_last;
	struct link* prev;
};

static void print_links(struct link* link)
{
	if (!link) return;
	
	print_links(link->prev);
	
	if (link->is_last)
		fputs("    ", stdout);
	else
		fputs("│   ", stdout);
}

static void print_tree_escape(char *out, char in)
{
	switch (in)
	{
		case ' ':
		case '~':
		case '!':
		case '@':
		case '#':
		case '$':
		case '%':
		case '^':
		case '&':
		case '*':
		case '-':
		case '+':
		case '=':
		case '|':
		case '<': case '>':
		case '(': case ')':
		case '{': case '}':
		case '[': case ']':
		case ':': case ';':
		case ',': case '.':
		case '_':
		case '`':
		case '0' ... '9':
		case 'a' ... 'z':
		case 'A' ... 'Z':
			*out++ = in;
			*out = 0;
			break;
		
		case '\\': *out++ = '\\', *out++ = '\\', *out = 0; break;
		
		case '\'': *out++ = '\\', *out++ = '\'', *out = 0; break;
		
		case '\"': *out++ = '\\', *out++ = '\"', *out = 0; break;
		
		case '\t': *out++ = '\\', *out++ = 't', *out = 0; break;
		
		case '\n': *out++ = '\\', *out++ = 'n', *out = 0; break;
		
		default:
			sprintf(out, "\\x%02X", in);
			break;
	}
}

enum prefix
{
	p_root,
	p_not_last_child,
	p_last_child,
};

void print_token_leaf(struct link* links, enum prefix p, const char* name, struct zebu_token* token)
{
	print_links(links);
	switch (p)
	{
		case p_root: break;
		case p_not_last_child: fputs("├── ", stdout); break;
		case p_last_child: fputs("└── ", stdout); break;
	}
	printf("\e[32m%s\e[0m (\e[35m\"", name);
	char escape[10];
	for (unsigned i = 0, n = token->len; i < n; i++)
		print_tree_escape(escape, token->data[i]), fputs(escape, stdout);
	printf("\"\e[0m)\n");
}

void print_scanf_leaf(struct link* links, enum prefix p, const char* name, const char* format, ...)
{
	va_list ap;
	print_links(links);
	switch (p)
	{
		case p_root: break;
		case p_not_last_child: fputs("├── ", stdout); break;
		case p_last_child: fputs("└── ", stdout); break;
	}
	printf("\e[32m%s\e[0m (\e[35m%s\e[m: \e[35m", name, format);
	va_start(ap, format);
	vprintf(format, ap);
	va_end(ap);
	printf("\e[0m)\n");
}

void print_empty_leaf(struct link* links, enum prefix p, const char* type, const char* name)
{
	print_links(links);
	switch (p)
	{
		case p_root: break;
		case p_not_last_child: fputs("├── ", stdout); break;
		case p_last_child: fputs("└── ", stdout); break;
	}
	printf("\e[31m%s\e[0m (\e[36m%s\e[0m)\n", name, type);
}
void print_zebu_$start(struct link* links, enum prefix p, const char* name, struct zebu_$start* ptree);

void print_zebu_keyvalue(struct link* links, enum prefix p, const char* name, struct zebu_keyvalue* ptree);

void print_zebu_value(struct link* links, enum prefix p, const char* name, struct zebu_value* ptree);

void print_zebu_$start(struct link* links, enum prefix p, const char* name, struct zebu_$start* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36m$start\e[m)\n", name);
	if (ptree->value)
		print_zebu_value(new ?: links, p_last_child, "value", ptree->value);
	else
		print_empty_leaf(new ?: links, p_last_child, "value", "value");
	free(new);
}
void print_zebu_keyvalue(struct link* links, enum prefix p, const char* name, struct zebu_keyvalue* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mkeyvalue\e[m)\n", name);
	print_scanf_leaf(new ?: links, p_not_last_child, "key", "%s", ptree->key);
	if (ptree->value)
		print_zebu_value(new ?: links, p_last_child, "value", ptree->value);
	else
		print_empty_leaf(new ?: links, p_last_child, "value", "value");
	free(new);
}
void print_zebu_value(struct link* links, enum prefix p, const char* name, struct zebu_value* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mvalue\e[m)\n", name);
	if (ptree->decimal)
		print_token_leaf(new ?: links, p_not_last_child, "decimal", ptree->decimal);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "token", "decimal");
	if (ptree->dict)
		print_token_leaf(new ?: links, p_not_last_child, "dict", ptree->dict);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "token", "dict");
	if (ptree->elements.n)
	{
		for (unsigned i = 0, n = ptree->elements.n; i < n; i++)
		{
			char label[8 + 30];
			snprintf(label, sizeof(label), "elements[%u]", i);
			print_zebu_value(new ?: links, i + 1 < n ? p_not_last_child : p_not_last_child, label, ptree->elements.data[i]);
		}
	}
	else
	{
		print_empty_leaf(new ?: links, p_not_last_child, "value[]", "elements");
	}
	if (ptree->entries.n)
	{
		for (unsigned i = 0, n = ptree->entries.n; i < n; i++)
		{
			char label[7 + 30];
			snprintf(label, sizeof(label), "entries[%u]", i);
			print_zebu_keyvalue(new ?: links, i + 1 < n ? p_not_last_child : p_not_last_child, label, ptree->entries.data[i]);
		}
	}
	else
	{
		print_empty_leaf(new ?: links, p_not_last_child, "keyvalue[]", "entries");
	}
	print_scanf_leaf(new ?: links, p_not_last_child, "integer", "%s", ptree->integer);
	if (ptree->list)
		print_token_leaf(new ?: links, p_not_last_child, "list", ptree->list);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "token", "list");
	print_scanf_leaf(new ?: links, p_last_child, "string", "%s", ptree->string);
	free(new);
}

#endif

struct zebu_token* inc_zebu_token(struct zebu_token* token)
{
	if (token) token->refcount++;
	return token;
}
struct zebu_$start* inc_zebu_$start(struct zebu_$start* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_keyvalue* inc_zebu_keyvalue(struct zebu_keyvalue* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_value* inc_zebu_value(struct zebu_value* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}



extern void free_zebu_token(struct zebu_token* token);
extern void free_zebu_$start(struct zebu_$start* ptree);

extern void free_zebu_keyvalue(struct zebu_keyvalue* ptree);

extern void free_zebu_value(struct zebu_value* ptree);

void free_zebu_token(struct zebu_token* token)
{
	if (token && !--token->refcount)
	{
		free(token->data);
		free(token);
	}
}
void free_zebu_$start(struct zebu_$start* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_value(ptree->value);
		free(ptree);
	}
}

void free_zebu_keyvalue(struct zebu_keyvalue* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free(ptree->key);
		free_zebu_value(ptree->value);
		free(ptree);
	}
}

void free_zebu_value(struct zebu_value* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_token(ptree->decimal);
		free_zebu_token(ptree->dict);
		for (unsigned i = 0, n = ptree->elements.n; i < n; i++)
			free_zebu_value(ptree->elements.data[i]);
		free(ptree->elements.data);
		for (unsigned i = 0, n = ptree->entries.n; i < n; i++)
			free_zebu_keyvalue(ptree->entries.data[i]);
		free(ptree->entries.data);
		free(ptree->integer);
		free_zebu_token(ptree->list);
		free(ptree->string);
		free(ptree);
	}
}



#define N(array) (sizeof(array) / sizeof(*array))

#ifdef ZEBU_DEBUG
static void escape(char *out, unsigned char in)
{
	switch (in)
	{
		case ' ':
		case '~':
		case '!':
		case '@':
		case '#':
		case '$':
		case '%':
		case '^':
		case '&':
		case '*':
		case '-':
		case '+':
		case '=':
		case '|':
		case '<': case '>':
		case '(': case ')':
		case '{': case '}':
		case '[': case ']':
		case ':': case ';':
		case ',': case '.':
		case '_':
		case '0' ... '9':
		case 'a' ... 'z':
		case 'A' ... 'Z':
			*out++ = in;
			*out = 0;
			break;
		
		case '\\': *out++ = '\\', *out++ = '\\', *out = 0; break;
		
		case '\"': *out++ = '\\', *out++ = '\"', *out = 0; break;
		
		case '\t': *out++ = '\\', *out++ = 't', *out = 0; break;
		
		case '\n': *out++ = '\\', *out++ = 'n', *out = 0; break;
		
		default:
			sprintf(out, "\\x%02X", in);
			break;
	}
}
#endif

struct zebu_$start* zebu_parse(FILE* stream)
{
	void* root;
	struct { unsigned* data, n, cap; } yacc = {};
	struct { void** data; unsigned n, cap; } data = {};
	struct { unsigned char* data; unsigned n, cap; } lexer = {};
	
	void push_state(unsigned y)
	{
		if (yacc.n + 1 >= yacc.cap)
		{
			yacc.cap = yacc.cap << 1 ?: 1;
			yacc.data = realloc(yacc.data, sizeof(*yacc.data) * yacc.cap);
		}
		yacc.data[yacc.n++] = y;
	}
	
	void push_data(void* d)
	{
		if (data.n + 1 >= data.cap)
		{
			data.cap = data.cap << 1 ?: 1;
			data.data = realloc(data.data, sizeof(*data.data) * data.cap);
		}
		data.data[data.n++] = d;
	}
	
	#ifdef ZEBU_DEBUG
	void ddprintf(const char* fmt, ...)
	{
		for (unsigned i = 0, n = yacc.n; i < n; i++)
			printf("%u ", yacc.data[i]);
		
		printf("| ");
		
		va_list va;
		va_start(va, fmt);
		vprintf(fmt, va);
		va_end(va);
	}
	#endif
	
	unsigned y, t, s, r;
	void* td;
	
	void read_token(unsigned l)
	{
		void append(unsigned char c)
		{
			while (lexer.n + 1 >= lexer.cap)
			{
				lexer.cap = lexer.cap << 1 ?: 1;
				#ifdef ZEBU_DEBUG
				ddprintf("lexer.cap == %u\n", lexer.cap);
				#endif
				lexer.data = realloc(lexer.data, lexer.cap);
			}
			
			lexer.data[lexer.n++] = c;
		}
		
		unsigned original_l = l, i = 0, a, b, c, f = 0;
		
		t = 0;
		
		#ifdef ZEBU_DEBUG
		ddprintf("lexer: \"%.*s\": l = %u\n", lexer.n, lexer.data, l);
		#endif
		
		while (1)
		{
			if (i < lexer.n)
			{
				c = lexer.data[i];
				
				#ifdef ZEBU_DEBUG
				char escaped[10];
				
				escape(escaped, c);
				
				ddprintf("lexer: c = '%s' (0x%X) (from cache)\n", escaped, c);
				#endif
				
				a = l < N(zebu_lexer) && c < N(*zebu_lexer) ? zebu_lexer[l][c] : 0;
			}
			else if ((c = getc(stream)) != EOF)
			{
				append(c);
				
				#ifdef ZEBU_DEBUG
				char escaped[10];
				
				escape(escaped, c);
				
				ddprintf("lexer: c = '%s' (0x%X)\n", escaped, c);
				#endif
				
				a = l < N(zebu_lexer) && c < N(*zebu_lexer) ? zebu_lexer[l][c] : 0;
			}
			else
			{
				c = EOF;
				
				#ifdef ZEBU_DEBUG
				ddprintf("lexer: c = <EOF>\n");
				#endif
				
				a = l < N(zebu_lexer_EOFs) ? zebu_lexer_EOFs[l] : 0;
			}
			
			b = l < N(zebu_lexer_accepts) ? zebu_lexer_accepts[l] : 0;
			
			#ifdef ZEBU_DEBUG
			ddprintf("lexer: \"%.*s\" (%u): a = %u, b = %u\n", lexer.n, lexer.data, i, a, b);
			#endif
			
			if (a)
			{
				if (b)
				{
					l = a, t = b, f = i++;
					#ifdef ZEBU_DEBUG
					ddprintf("lexer: l = %u\n", l);
					#endif
				}
				else
				{
					l = a, i++;
					#ifdef ZEBU_DEBUG
					ddprintf("lexer: l = %u\n", l);
					#endif
				}
			}
			else if (b)
			{
				#ifdef ZEBU_DEBUG
				ddprintf("lexer: token: \"%.*s\"\n", i, lexer.data);
				#endif
				
				if (!lexer.n)
				{
					#ifdef ZEBU_DEBUG
					ddprintf("lexer: EOF.\n");
					#endif
					t = b, td = NULL;
					break;
				}
				else if (b == 1)
				{
					#ifdef ZEBU_DEBUG
					ddprintf("lexer: whitespace: \"%.*s\"\n", i, lexer.data);
					#endif
					
					l = original_l, t = 0;
					memmove(lexer.data, lexer.data + i, lexer.n - i), lexer.n -= i, i = 0;
				}
				else
				{
					#ifdef ZEBU_DEBUG
					ddprintf("lexer: i = %u\n", i);
					#endif
					
					struct zebu_token* token = malloc(sizeof(*token));
					token->refcount = 1;
					token->data = memcpy(malloc(i + 1), lexer.data, i);
					token->len = i;
					token->data[i] = 0;
					t = b, td = token;
					
					memmove(lexer.data, lexer.data + i, lexer.n - i), lexer.n -= i;
					break;
				}
			}
			else if (f)
			{
				if (t == 1)
				{
					#ifdef ZEBU_DEBUG
					ddprintf("lexer: falling back to whitespace: \"%.*s\"\n", f, lexer.data);
					#endif
					
					l = original_l, t = 0;
					memmove(lexer.data, lexer.data + f, lexer.n - f), lexer.n -= f, f = 0, i = 0;
				}
				else
				{
					#ifdef ZEBU_DEBUG
					ddprintf("lexer: falling back to token: \"%.*s\"\n", f, lexer.data);
					#endif
					
					struct zebu_token* token = malloc(sizeof(*token));
					token->refcount = 1;
					token->data = memcpy(malloc(f + 1), lexer.data, f);
					token->len = f;
					token->data[f] = 0;
					td = token;
					
					memmove(lexer.data, lexer.data + f, lexer.n - f), lexer.n -= f, f = 0;
					break;
				}
			}
			else
			{
				fprintf(stderr, "zebu: unexpected '%c' when reading ...'%.*s'!\n", c, i, lexer.data);
				abort();
			}
		}
	}
	
	push_state(1), y = 1, read_token(1);
	
	#ifdef ZEBU_DEBUG
	ddprintf("y = %u, t = %u\n", y, t);
	#endif
	
	while (yacc.n)
	{
		if (y < N(zebu_shifts) && t < N(*zebu_shifts) && (s = zebu_shifts[y][t]))
		{
			#ifdef ZEBU_DEBUG
			ddprintf("s == %u\n", s);
			#endif
			
			y = s, push_state(y), push_data(td);
			
			read_token(zebu_lexer_starts[y]);
			
			#ifdef ZEBU_DEBUG
			ddprintf("t = %u\n", t);
			#endif
		}
		else if (y < N( zebu_reduces) && t < N(*zebu_reduces) && (r = zebu_reduces[y][t]))
		{
			#ifdef ZEBU_DEBUG
			ddprintf("r == %u\n", r);
			#endif
			
			unsigned g;
			void* d;
			
			switch (r)
{
	case 4:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_value* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_value(value->value), value->value = inc_zebu_value(subgrammar);
		free_zebu_value(subgrammar);
		}
		d = value, g = 5;
		break;
	}
	case 12:
	{
		struct zebu_value* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_value* trie = data.data[--yacc.n, --data.n];
			if (trie->decimal) { free_zebu_token(value->decimal); value->decimal = inc_zebu_token(trie->decimal); }
			if (trie->dict) { free_zebu_token(value->dict); value->dict = inc_zebu_token(trie->dict); }
			if (trie->elements.n)
			{
				while (value->elements.n + trie->elements.n > value->elements.cap)
				{
					value->elements.cap = value->elements.cap << 1 ?: 1;
					value->elements.data = realloc(value->elements.data, sizeof(*value->elements.data) * value->elements.cap);
				}
				memmove(value->elements.data + trie->elements.n, value->elements.data, sizeof(*value->elements.data) * value->elements.n);
				for (unsigned i = 0, n = trie->elements.n; i < n; i++)
					value->elements.data[i] = inc_zebu_value(trie->elements.data[i]);
				value->elements.n += trie->elements.n;
			}
			if (trie->entries.n)
			{
				while (value->entries.n + trie->entries.n > value->entries.cap)
				{
					value->entries.cap = value->entries.cap << 1 ?: 1;
					value->entries.data = realloc(value->entries.data, sizeof(*value->entries.data) * value->entries.cap);
				}
				memmove(value->entries.data + trie->entries.n, value->entries.data, sizeof(*value->entries.data) * value->entries.n);
				for (unsigned i = 0, n = trie->entries.n; i < n; i++)
					value->entries.data[i] = inc_zebu_keyvalue(trie->entries.data[i]);
				value->entries.n += trie->entries.n;
			}
			if (trie->integer) { value->integer = trie->integer; }
			if (trie->list) { free_zebu_token(value->list); value->list = inc_zebu_token(trie->list); }
			if (trie->string) { value->string = trie->string; }
			free_zebu_value(trie);
		}
		{
		struct zebu_value* subgrammar = data.data[--yacc.n, --data.n];
		if (value->elements.n == value->elements.cap)
		{
			value->elements.cap = value->elements.cap << 1 ?: 1;
			value->elements.data = realloc(value->elements.data, sizeof(*value->elements.data) * value->elements.cap);
		}
		memmove(value->elements.data + 1, value->elements.data, sizeof(*value->elements.data) * value->elements.n);
		value->elements.data[0] = inc_zebu_value(subgrammar), value->elements.n++;
		free_zebu_value(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		d = value, g = 3;
		break;
	}
	case 7:
	{
		struct zebu_value* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		d = value, g = 3;
		break;
	}
	case 13:
	{
		struct zebu_value* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_value* trie = data.data[--yacc.n, --data.n];
			if (trie->decimal) { free_zebu_token(value->decimal); value->decimal = inc_zebu_token(trie->decimal); }
			if (trie->dict) { free_zebu_token(value->dict); value->dict = inc_zebu_token(trie->dict); }
			if (trie->elements.n)
			{
				while (value->elements.n + trie->elements.n > value->elements.cap)
				{
					value->elements.cap = value->elements.cap << 1 ?: 1;
					value->elements.data = realloc(value->elements.data, sizeof(*value->elements.data) * value->elements.cap);
				}
				memmove(value->elements.data + trie->elements.n, value->elements.data, sizeof(*value->elements.data) * value->elements.n);
				for (unsigned i = 0, n = trie->elements.n; i < n; i++)
					value->elements.data[i] = inc_zebu_value(trie->elements.data[i]);
				value->elements.n += trie->elements.n;
			}
			if (trie->entries.n)
			{
				while (value->entries.n + trie->entries.n > value->entries.cap)
				{
					value->entries.cap = value->entries.cap << 1 ?: 1;
					value->entries.data = realloc(value->entries.data, sizeof(*value->entries.data) * value->entries.cap);
				}
				memmove(value->entries.data + trie->entries.n, value->entries.data, sizeof(*value->entries.data) * value->entries.n);
				for (unsigned i = 0, n = trie->entries.n; i < n; i++)
					value->entries.data[i] = inc_zebu_keyvalue(trie->entries.data[i]);
				value->entries.n += trie->entries.n;
			}
			if (trie->integer) { value->integer = trie->integer; }
			if (trie->list) { free_zebu_token(value->list); value->list = inc_zebu_token(trie->list); }
			if (trie->string) { value->string = trie->string; }
			free_zebu_value(trie);
		}
		{
		struct zebu_keyvalue* subgrammar = data.data[--yacc.n, --data.n];
		if (value->entries.n == value->entries.cap)
		{
			value->entries.cap = value->entries.cap << 1 ?: 1;
			value->entries.data = realloc(value->entries.data, sizeof(*value->entries.data) * value->entries.cap);
		}
		memmove(value->entries.data + 1, value->entries.data, sizeof(*value->entries.data) * value->entries.n);
		value->entries.data[0] = inc_zebu_keyvalue(subgrammar), value->entries.n++;
		free_zebu_keyvalue(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		d = value, g = 4;
		break;
	}
	case 9:
	{
		struct zebu_value* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		d = value, g = 4;
		break;
	}
	case 11:
	{
		struct zebu_keyvalue* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_value* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_value(value->value), value->value = inc_zebu_value(subgrammar);
		free_zebu_value(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		value->key = strdup((char*) token->data);
		free_zebu_token(token);
		}
		d = value, g = 2;
		break;
	}
	case 8:
	{
		struct zebu_value* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_value* trie = data.data[--yacc.n, --data.n];
			if (trie->decimal) { free_zebu_token(value->decimal); value->decimal = inc_zebu_token(trie->decimal); }
			if (trie->dict) { free_zebu_token(value->dict); value->dict = inc_zebu_token(trie->dict); }
			if (trie->elements.n)
			{
				while (value->elements.n + trie->elements.n > value->elements.cap)
				{
					value->elements.cap = value->elements.cap << 1 ?: 1;
					value->elements.data = realloc(value->elements.data, sizeof(*value->elements.data) * value->elements.cap);
				}
				memmove(value->elements.data + trie->elements.n, value->elements.data, sizeof(*value->elements.data) * value->elements.n);
				for (unsigned i = 0, n = trie->elements.n; i < n; i++)
					value->elements.data[i] = inc_zebu_value(trie->elements.data[i]);
				value->elements.n += trie->elements.n;
			}
			if (trie->entries.n)
			{
				while (value->entries.n + trie->entries.n > value->entries.cap)
				{
					value->entries.cap = value->entries.cap << 1 ?: 1;
					value->entries.data = realloc(value->entries.data, sizeof(*value->entries.data) * value->entries.cap);
				}
				memmove(value->entries.data + trie->entries.n, value->entries.data, sizeof(*value->entries.data) * value->entries.n);
				for (unsigned i = 0, n = trie->entries.n; i < n; i++)
					value->entries.data[i] = inc_zebu_keyvalue(trie->entries.data[i]);
				value->entries.n += trie->entries.n;
			}
			if (trie->integer) { value->integer = trie->integer; }
			if (trie->list) { free_zebu_token(value->list); value->list = inc_zebu_token(trie->list); }
			if (trie->string) { value->string = trie->string; }
			free_zebu_value(trie);
		}
		{
		struct zebu_value* subgrammar = data.data[--yacc.n, --data.n];
		if (value->elements.n == value->elements.cap)
		{
			value->elements.cap = value->elements.cap << 1 ?: 1;
			value->elements.data = realloc(value->elements.data, sizeof(*value->elements.data) * value->elements.cap);
		}
		memmove(value->elements.data + 1, value->elements.data, sizeof(*value->elements.data) * value->elements.n);
		value->elements.data[0] = inc_zebu_value(subgrammar), value->elements.n++;
		free_zebu_value(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->list), value->list = inc_zebu_token(token);
		free_zebu_token(token);
		}
		d = value, g = 1;
		break;
	}
	case 3:
	{
		struct zebu_value* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->decimal), value->decimal = inc_zebu_token(token);
		free_zebu_token(token);
		}
		d = value, g = 1;
		break;
	}
	case 2:
	{
		struct zebu_value* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		value->integer = strdup((char*) token->data);
		free_zebu_token(token);
		}
		d = value, g = 1;
		break;
	}
	case 1:
	{
		struct zebu_value* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		value->string = strdup((char*) token->data);
		free_zebu_token(token);
		}
		d = value, g = 1;
		break;
	}
	case 10:
	{
		struct zebu_value* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_value* trie = data.data[--yacc.n, --data.n];
			if (trie->decimal) { free_zebu_token(value->decimal); value->decimal = inc_zebu_token(trie->decimal); }
			if (trie->dict) { free_zebu_token(value->dict); value->dict = inc_zebu_token(trie->dict); }
			if (trie->elements.n)
			{
				while (value->elements.n + trie->elements.n > value->elements.cap)
				{
					value->elements.cap = value->elements.cap << 1 ?: 1;
					value->elements.data = realloc(value->elements.data, sizeof(*value->elements.data) * value->elements.cap);
				}
				memmove(value->elements.data + trie->elements.n, value->elements.data, sizeof(*value->elements.data) * value->elements.n);
				for (unsigned i = 0, n = trie->elements.n; i < n; i++)
					value->elements.data[i] = inc_zebu_value(trie->elements.data[i]);
				value->elements.n += trie->elements.n;
			}
			if (trie->entries.n)
			{
				while (value->entries.n + trie->entries.n > value->entries.cap)
				{
					value->entries.cap = value->entries.cap << 1 ?: 1;
					value->entries.data = realloc(value->entries.data, sizeof(*value->entries.data) * value->entries.cap);
				}
				memmove(value->entries.data + trie->entries.n, value->entries.data, sizeof(*value->entries.data) * value->entries.n);
				for (unsigned i = 0, n = trie->entries.n; i < n; i++)
					value->entries.data[i] = inc_zebu_keyvalue(trie->entries.data[i]);
				value->entries.n += trie->entries.n;
			}
			if (trie->integer) { value->integer = trie->integer; }
			if (trie->list) { free_zebu_token(value->list); value->list = inc_zebu_token(trie->list); }
			if (trie->string) { value->string = trie->string; }
			free_zebu_value(trie);
		}
		{
		struct zebu_keyvalue* subgrammar = data.data[--yacc.n, --data.n];
		if (value->entries.n == value->entries.cap)
		{
			value->entries.cap = value->entries.cap << 1 ?: 1;
			value->entries.data = realloc(value->entries.data, sizeof(*value->entries.data) * value->entries.cap);
		}
		memmove(value->entries.data + 1, value->entries.data, sizeof(*value->entries.data) * value->entries.n);
		value->entries.data[0] = inc_zebu_keyvalue(subgrammar), value->entries.n++;
		free_zebu_keyvalue(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->dict), value->dict = inc_zebu_token(token);
		free_zebu_token(token);
		}
		d = value, g = 1;
		break;
	}
	case 5:
	{
		struct zebu_value* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->list), value->list = inc_zebu_token(token);
		free_zebu_token(token);
		}
		d = value, g = 1;
		break;
	}
	case 6:
	{
		struct zebu_value* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->dict), value->dict = inc_zebu_token(token);
		free_zebu_token(token);
		}
		d = value, g = 1;
		break;
	}
}
			
			if (g == 5)
			{
				free_zebu_token(td);
				yacc.n = 0, root = d;
			}
			else
			{
				y = yacc.data[yacc.n - 1];
				
				#ifdef ZEBU_DEBUG
				ddprintf("y = %u\n", y);
				#endif
				
				assert(y < N(zebu_gotos) && g < N(*zebu_gotos));
				
				s = zebu_gotos[y][g];
				
				#ifdef ZEBU_DEBUG
				ddprintf("s = %u\n", s);
				#endif
				
				y = s, push_state(y), push_data(d);
			}
		}
		else
		{
			assert(!"266");
		}
	}
	
	#ifdef ZEBU_DEBUG
	print_zebu_$start(NULL, p_root, "start", root);
	#endif
	
	free(yacc.data);
	free(data.data);
	free(lexer.data);
	
	return root;
}

















